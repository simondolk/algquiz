<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quiz – Flera kategorier</title>
<style>
  :root{--bg:#0f172a;--card:#111827;--text:#e5e7eb;--muted:#9ca3af;--accent:#22c55e;--danger:#ef4444;--btn:#1f2937;--btn-text:#e5e7eb}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;background:var(--bg);color:var(--text)}
  header{padding:16px 20px;border-bottom:1px solid #1f2937;display:flex;gap:16px;flex-wrap:wrap;align-items:center}
  header h1{font-size:20px;margin:0}
  main{max-width:980px;margin:0 auto;padding:20px}
  .toolbar{display:flex;gap:12px;align-items:center;flex-wrap:wrap;color:var(--muted)}
  select, input[type="text"], button{background:var(--btn);color:var(--btn-text);border:1px solid #374151;border-radius:8px;padding:8px 10px}
  label{color:var(--muted);font-size:14px}
  .card{background:var(--card);border:1px solid #1f2937;border-radius:12px;overflow:hidden}
  .card .media{position:relative;display:grid;place-items:center;background:#0b1220;aspect-ratio:16/9}
  .card img{max-width:100%;max-height:70vh;object-fit:contain}
  .nav{position:absolute;top:50%;transform:translateY(-50%);border:none;background:rgba(15,23,42,.6);color:#e5e7eb;width:40px;height:48px;border-radius:8px;display:grid;place-items:center;cursor:pointer}
  .nav:hover{background:rgba(15,23,42,.8)}
  .nav.prev{left:8px}
  .nav.next{right:8px}
  .counter{position:absolute;bottom:8px;right:10px;background:rgba(2,6,23,.6);padding:2px 8px;border-radius:999px;font-size:12px;color:#cbd5e1}
  .card .content{padding:16px;display:grid;gap:12px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .stats{color:var(--muted)}
  .choices{display:grid;gap:8px}
  .choice{display:flex;gap:8px;align-items:center}
  .help{color:var(--muted);font-size:14px}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#1e293b;color:#cbd5e1;font-size:12px;cursor:default}
  .ok{color:var(--accent)}
  .bad{color:var(--danger)}
  footer{padding:20px;color:#94a3b8;text-align:center}
  @media (max-width:480px){ .nav{width:32px;height:40px} }
</style>
</head>
<body>
  <header>
    <h1 id="title">Quiz</h1>
    <div class="toolbar">
      <label for="categorySelect">Kategori</label>
      <select id="categorySelect"></select>
      <span class="badge" id="modeBadge" title="Klicka för att växla">Läge: Fritext</span>
      <label><input type="checkbox" id="shuffleToggle"> Blanda frågor</label>
    </div>
    <div class="stats" id="stats">Fråga: – / – · Poäng: 0</div>
  </header>

  <main>
    <article class="card">
      <div class="media">
        <button class="nav prev" id="imgPrevBtn" aria-label="Föregående bild">◀</button>
        <img id="image" alt="Bild för aktuell fråga"/>
        <button class="nav next" id="imgNextBtn" aria-label="Nästa bild">▶</button>
        <div class="counter" id="imageCounter">1/1</div>
      </div>
      <div class="content">
        <h2 id="prompt">Vad heter denna art?</h2>
        <!-- diskret taxa-info (group/subgroup) -->
        <div class="help" id="taxaBadge"></div>

        <div class="row" id="freeRow">
          <input id="answerInput" type="text" placeholder="Skriv svaret här…" size="40"/>
          <button id="checkBtn">Kontrollera</button>
        </div>
        <div class="choices" id="mcRow" style="display:none"></div>
        <div class="row">
          <button id="revealBtn">Visa rätt svar</button>
          <button id="nextBtn">Nästa →</button>
          <span id="feedback"></span>
        </div>
        <div class="help">
          Tips: Endast skiftläge ignoreras och mellanslag accepteras (särskrivning). Inga övriga stavfel.
        </div>
      </div>
    </article>
  </main>

  <footer>© <span id="byline">Simon Dolk</span></footer>

<script>
(function(){
  const CATEGORY_KEY='quiz.category';
  const MODE_KEY='quiz.mode'; // 'free' | 'mc'
  const SHUFFLE_KEY='quiz.shuffle';

  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));

  const els = {
    title: $('#title'), byline: $('#byline'), cat: $('#categorySelect'),
    mode: $('#modeBadge'), shuffle: $('#shuffleToggle'),
    stats: $('#stats'), img: $('#image'), prompt: $('#prompt'),
    freeRow: $('#freeRow'), input: $('#answerInput'),
    mcRow: $('#mcRow'),
    check: $('#checkBtn'), reveal: $('#revealBtn'), next: $('#nextBtn'),
    feedback: $('#feedback'),
    prev: $('#imgPrevBtn'), nextImg: $('#imgNextBtn'), counter: $('#imageCounter')
  };

  // State
  let categories = [];
  let data = { title: 'Quiz', questions: [] };
  let order = [];
  let i = 0; // index in order
  let score = 0;
  let seen = new Set();
  let imgIdx = 0;

  // Settings
  let mode = localStorage.getItem(MODE_KEY) || 'free';
  let shuffle = localStorage.getItem(SHUFFLE_KEY) === '1';
  els.shuffle.checked = shuffle;

  function setMode(m){
    mode = m; localStorage.setItem(MODE_KEY, m);
    els.mode.textContent = 'Läge: ' + (m==='free' ? 'Fritext' : 'Flervalsfråga');
    els.freeRow.style.display = (m==='free')?'flex':'none';
    els.mcRow.style.display = (m==='mc')?'grid':'none';
    els.feedback.textContent = '';
    els.feedback.className = '';
  }
  setMode(mode);

  // === Filename variant helpers ===
  function pathParts(p){
    const m = p.match(/^(.*\/)?([^\/]+)$/); // dir, file
    const dir = (m && m[1]) || '';
    const file = (m && m[2]) || p;
    const m2 = file.match(/^(.*?)(\.[^.]+)?$/);
    const base = m2[1];
    const ext = (m2[2]||'').toLowerCase();
    return {dir, base, ext};
  }
  function extVariants(ext){
    const core = ['.jpg','.jpeg','.png'];
    const set = new Set([ext.toLowerCase(), ...core]);
    const out = [];
    set.forEach(e=>{ out.push(e); out.push(e.toUpperCase()); });
    return [...new Set(out)];
  }
  function numberStrippers(base){
    // remove trailing _n or -n if present
    const m = base.match(/^(.*?)_-$/);
    return m ? m[1] : base;
  }
  function buildVariants(p){
    const {dir, base, ext} = pathParts(p);
    const root = numberStrippers(base);
    const exts = extVariants(ext || '.jpg');
    const names = new Set();
    const push = s => names.add(dir + s);
    const stems = [root, root+'_1', root+'_2', root+'_3', root+'_4', root+'-1', root+'-2', root+'-3', root+'-4'];
    stems.forEach(st => exts.forEach(e => push(st+e)));
    return [...names];
  }

  function normalize(s){ return (s||'').toLowerCase().replace(/\s+/g,''); }
  function isCorrect(input, answers){
    const n = normalize(input);
    return (answers||[]).some(a => normalize(a)===n);
  }
  function registerResult(ok){
    if(ok && !seen.has(order[i])){ score++; seen.add(order[i]); updateStats(); }
  }

  // ===== NEW HELPERS for new data format + subgroup-aware MC =====
  function uniq(arr){ 
    return [...new Set((arr || []).filter(Boolean))]; 
  }

  function getSubgroup(q){
    // Reads subgroup from standardized question object (preferred),
    // or from possible legacy meta.
    return q.subgroup || q.group || (q.meta && (q.meta.subgroup || q.meta.group)) || '';
  }

  // Subgroup index: subgroup -> array of question objects
  let bySubgroup = new Map();
  function indexBySubgroup(){
    bySubgroup.clear();
    (data.questions || []).forEach(q => {
      const g = getSubgroup(q);
      if(!g) return;
      if(!bySubgroup.has(g)) bySubgroup.set(g, []);
      bySubgroup.get(g).push(q);
    });
  }

  // Map a record from the new array schema into the internal question schema
  function mapRecordToQuestion(rec){
    const answers = uniq([rec.commonName, rec.latinName, ...(rec.aliases || [])]);
    const images = (rec.images && rec.images.length) ? rec.images : (rec.image ? [rec.image] : []);
    return {
      answers,
      images,
      subgroup: rec.subgroup || rec.group || '',
      group: rec.group || '',
      commonName: rec.commonName || '',
      latinName: rec.latinName || ''
    };
  }

  function sample(arr, k){
    const a=[...arr];
    for(let j=a.length-1;j>0;--j){const r=Math.floor(Math.random()*(j+1)); [a[j],a[r]]=[a[r],a[j]]}
    return a.slice(0,k);
  }

  function buildOrder(){
    order = data.questions.map((_,idx)=>idx);
    if(shuffle){ order = sample(order, order.length); }
    i = 0; score = 0; seen.clear();
  }

  function current(){ return data.questions[order[i]]; }

  function toImagesList(q){
    let candidates = [];
    if(q.images && q.images.length){ candidates = [...q.images]; }
    else if(q.image){ candidates = [q.image]; }
    // enrich with variant guesses for each candidate
    let enriched = [];
    candidates.forEach(p=>{ enriched.push(p); buildVariants(p).forEach(v=> enriched.push(v)); });
    // de-dup
    return [...new Set(enriched)];
  }

  function normalizeQuestion(q){
    if(!q.images || q.images.length===0){ q.images = toImagesList(q); }
    return q;
  }

  function updateStats(){
    els.stats.textContent = `Fråga: ${i+1} / ${order.length} · Poäng: ${score}`;
  }
 async function validateImages(q){
  if(q._validImages) return q._validImages;
  // ANVÄND ALLTID ENRICHED VARIANTS:
  const candidates = toImagesList(q);

  const checks = await Promise.all(
    candidates.map(url => new Promise(res => {
      const img = new Image();
      img.onload = () => res(url);
      img.onerror = () => res(null);
      img.src = url;
    }))
  );

  q._validImages = checks.filter(Boolean);
  return q._validImages;
}

  function updateCarouselUI(n){
    els.counter.textContent = n? `${imgIdx+1}/${n}` : '';
    const show = n>1 ? 'grid' : 'none';
    els.prev.style.display = show; els.nextImg.style.display = show;
  }

  async function showImage(){
    const q = normalizeQuestion(current());
    const imgs = await validateImages(q);
    const n = imgs.length;
    if(n===0){
      els.img.removeAttribute('src');
      updateCarouselUI(0);
      return;
    }
    imgIdx = (imgIdx + n) % n; // wrap
    els.img.src = imgs[imgIdx];
    updateCarouselUI(n);
  }

  function latinFromAnswers(ans){
    if(!ans || !ans.length) return '';
    const latinRegex = /^[A-ZÅÄÖ][a-zåäöéèê\-]+\s+[a-zåäöéèê\-\.]+$/;
    const found = ans.find(a => latinRegex.test(a.trim()));
    if(found) return found;
    return ans[1] || '';
  }

  function primaryCommon(ans){
    if(!ans || !ans.length) return '';
    // Prefer first entry that is NOT binomial latin
    const latinRegex = /^[A-ZÅÄÖ][a-zåäöéèê\-]+\s+[a-zåäöéèê\-\.]+$/;
    const nonLatin = ans.find(a => !latinRegex.test(a.trim()));
    return nonLatin || ans[0];
  }

  function render(){
    els.title.textContent = (data.title || 'Quiz');
    updateStats();
    const q = normalizeQuestion(current());
    imgIdx = 0; // reset for new question
    showImage();
    els.img.alt = 'Bild: ' + ((q.answers && q.answers[0]) || 'Okänd');
    els.prompt.textContent = 'Vad heter denna art?';
    els.input.value = '';
    els.feedback.textContent = '';
    els.feedback.className = '';

    // taxa badge (diskret)
    const badge = document.getElementById('taxaBadge');
    if (badge) {
      const grp = q.group ? q.group : '';
      const sub = q.subgroup ? ` · ${q.subgroup}` : '';
      badge.textContent = (grp || sub) ? `Kategori: ${grp}${sub}` : '';
    }

    // Build choices if needed
    if(mode==='mc'){
      const correct = (q.answers && primaryCommon(q.answers)) || '';
      const g = getSubgroup(q);

      // Primär pool: samma undergrupp (exkl. den aktuella frågan)
      const sameGroupQs = (bySubgroup.get(g) || []).filter(x => x !== q);
      let poolSame = uniq(
        sameGroupQs
          .map(x => (x.answers && primaryCommon(x.answers)) || '')
          .filter(x => x && x !== correct)
      );

      // Sekundär pool: allt annat i kategorin
      const allOther = data.questions.filter(x => x !== q && getSubgroup(x) !== g);
      let poolOther = uniq(
        allOther
          .map(x => (x.answers && primaryCommon(x.answers)) || '')
          .filter(x => x && x !== correct)
      );

      // 1 rätt + 3 distraktorer = 4 alternativ (om möjligt)
      const need = 3;
      let distractors = sample(poolSame, Math.min(need, poolSame.length));

      if (distractors.length < need) {
        const remaining = need - distractors.length;
        distractors = distractors.concat(sample(poolOther, Math.min(remaining, poolOther.length)));
      }

      // Sista fallback: fyll från alla primära namn, utan dubletter
      if (distractors.length < need) {
        const allPrimary = uniq(
          data.questions
            .filter(x => x !== q)
            .map(x => (x.answers && primaryCommon(x.answers)) || '')
            .filter(Boolean)
        ).filter(x => x !== correct && !distractors.includes(x));
        distractors = distractors.concat(sample(allPrimary, Math.max(0, need - distractors.length)));
      }

      let options = uniq([correct, ...distractors]);
      options = sample(options, options.length); // blanda

      els.mcRow.innerHTML = '';
      options.forEach(opt =>{
        const id = 'opt_'+Math.random().toString(36).slice(2,8);
        const div = document.createElement('div'); div.className='choice';
        div.innerHTML = `<input type="radio" name="mc" id="${id}" value="${opt}"><label for="${id}">${opt}</label>`;
        els.mcRow.appendChild(div);
      });
    }
  }

  function setFeedback(ok, q){
    if(ok){
      const latin = latinFromAnswers(q.answers);
      els.feedback.textContent = latin ? `Rätt – ${latin}` : 'Rätt!';
      els.feedback.className = 'ok';
    } else {
      els.feedback.textContent = 'Fel';
      els.feedback.className = 'bad';
    }
  }

  function handleCheck(){
    const q = current();
    let ok=false;
    if(mode==='free'){
      ok = isCorrect(els.input.value, q.answers);
    } else {
      const sel = document.querySelector('input[name="mc"]:checked');
      ok = !!sel && isCorrect(sel.value, q.answers);
    }
    setFeedback(ok, q);
    registerResult(ok);
  }

  function handleMCSelection(e){
    if(e.target && e.target.name==='mc'){
      const q = current();
      const ok = isCorrect(e.target.value, q.answers);
      setFeedback(ok, q);
      registerResult(ok);
    }
  }

  function handleReveal(){
    const q = current();
    const common = primaryCommon(q.answers);
    const latin = latinFromAnswers(q.answers);
    els.feedback.textContent = latin ? `Rätt svar: ${common} — ${latin}` : `Rätt svar: ${common}`;
    els.feedback.className = '';
  }

  function handleNext(){
    if(order.length===0) return;
    i = (i+1) % order.length; render();
  }

  els.check.addEventListener('click', handleCheck);
  els.reveal.addEventListener('click', handleReveal);
  els.next.addEventListener('click', handleNext);
  els.mcRow.addEventListener('change', handleMCSelection);

  // Carousel controls
  els.prev.addEventListener('click', ()=>{ imgIdx--; showImage(); });
  els.nextImg.addEventListener('click', ()=>{ imgIdx++; showImage(); });
  document.addEventListener('keydown', (ev)=>{
    if(ev.key==='ArrowLeft'){ imgIdx--; showImage(); }
    if(ev.key==='ArrowRight'){ imgIdx++; showImage(); }
  });

  // Category loading
  async function loadCategories(){
    const cats = await fetch('data/categories.json').then(r=>r.json());
    categories = cats;
    els.cat.innerHTML = '';
    cats.forEach(c=>{
      const opt = document.createElement('option');
      opt.value = c.id; opt.textContent = c.name; els.cat.appendChild(opt);
    });
    const saved = localStorage.getItem(CATEGORY_KEY);
    if(saved && cats.some(c=>c.id===saved)) els.cat.value = saved;
    await loadCategory(els.cat.value || cats[0].id);
    // On change, persist + hard reload (ensures all listeners re-init properly)
    els.cat.addEventListener('change', e=>{
      const id = e.target.value; localStorage.setItem(CATEGORY_KEY, id); location.reload();
    });
  }

  async function loadCategory(id){
    const meta = categories.find(c=>c.id===id) || categories[0];
    localStorage.setItem(CATEGORY_KEY, meta.id);

    const raw = await fetch(meta.data).then(r=>r.json());

    if (Array.isArray(raw)) {
      // NEW: your new schema (array of records)
      data = { title: meta.name || 'Quiz', questions: raw.map(mapRecordToQuestion) };
    } else if (raw && Array.isArray(raw.questions)) {
      // Legacy schema
      data = raw;
    } else {
      throw new Error('Okänt dataformat i ' + meta.data);
    }

    indexBySubgroup();  // build subgroup index
    buildOrder();
    render();
  }

  // Mode toggle → persist + hard reload
  els.mode.addEventListener('click', ()=>{
    const m = (mode==='free'?'mc':'free');
    localStorage.setItem(MODE_KEY, m);
    location.reload();
  });

  // Shuffle change can be soft (no reload)
  els.shuffle.addEventListener('change', (e)=>{
    shuffle = e.target.checked; localStorage.setItem(SHUFFLE_KEY, shuffle?'1':'0');
    buildOrder(); render();
  });

  loadCategories().catch(err=>{
    console.error(err);
    els.prompt.textContent = 'Kunde inte ladda kategorierna. Kontrollera filvägarna.';
  });

})();
</script>
</body>
</html>
